<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Drafts on Trisha Gee </title>
    <link>http://trishagee.github.io/drafts/</link>
    <language>en-us</language>
    <author>Trisha Gee</author>
    <rights>Copyright (c) 2011 - 2014, Trisha Gee; all rights reserved.</rights>
    <updated>Thu, 30 Jul 2015 00:00:00 UTC</updated>
    
    <item>
      <title>CR</title>
      <link>http://trishagee.github.io/drafts/code_review_2/</link>
      <pubDate>Thu, 30 Jul 2015 00:00:00 UTC</pubDate>
      <author>Trisha Gee</author>
      <guid>http://trishagee.github.io/drafts/code_review_2/</guid>
      <description>

&lt;p&gt;In the last post we talked about a wide variety of things you could look for
in a code review.  Now we&amp;rsquo;ll focus on one area: what to look for in the
test code.&lt;/p&gt;

&lt;p&gt;This article assumes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Your team already writes automated tests for code.&lt;/li&gt;
&lt;li&gt;The tests are regularly run in a Continuous Integration (CI) environment.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In this post we&amp;rsquo;ll cover some of the things a reviewer could be thinking
about when looking at the tests in a code review.&lt;/p&gt;

&lt;h3 id=&#34;are-there-tests-for-this-new-amended-code:e49bb25edf62b34017ea72c340f0c27c&#34;&gt;Are there tests for this new/amended code?&lt;/h3&gt;

&lt;p&gt;It would be rare that new code, whether a bug fix or new feature, wouldn&amp;rsquo;t
need a new or updated test to cover it. Even changes for &amp;ldquo;non-functional&amp;rdquo;
reasons like performance can frequently be proved via a test. If there are no
tests included in the code review, as a reviewer the first question you
should ask is &amp;ldquo;why not?&amp;rdquo;.&lt;/p&gt;

&lt;h3 id=&#34;do-the-tests-at-least-cover-confusing-or-complicated-sections-of-code:e49bb25edf62b34017ea72c340f0c27c&#34;&gt;Do the tests at least cover confusing or complicated sections of code?&lt;/h3&gt;

&lt;p&gt;One step beyond simply &amp;ldquo;is there a test?&amp;rdquo;, is to answer the question &amp;ldquo;is the
important code actually covered by at least one test?&amp;ldquo;.&lt;/p&gt;

&lt;p&gt;Checking test coverage is certainly something we should be automating. But we
can do more than just check for specific percentages in our coverage, we can
use coverage tools to ensure the &lt;em&gt;correct&lt;/em&gt; areas of code are covered.&lt;/p&gt;

&lt;p&gt;Consider this for example:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://trishagee.github.io/static/images/code-review/CodeReviewChanges.png&#34; alt=&#34;New lines of code&#34; title=&#34;New lines of code&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;You can check the coverage report for the new lines of code (which should be easy to identify, especially if you&amp;rsquo;re
using a tool like Upsource) to make sure it&amp;rsquo;s adequately covered&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://trishagee.github.io/static/images/code-review/CodeReviewCoverage.png&#34; alt=&#34;Code coverage&#34; title=&#34;Code coverage&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;In this example above, the reviewer may ask the author to
add a test to cover the case where the &lt;code&gt;if&lt;/code&gt; on line 303 evaluates to true - the coverage tool is marking lines
304-306 with red to show they aren&amp;rsquo;t tested.&lt;/p&gt;

&lt;p&gt;100% test coverage is an unrealistic goal for pretty much any team, so the
numbers coming out of your coverage tool might not be as valuable as insights
into which specific areas are covered.&lt;/p&gt;

&lt;p&gt;In particular, you want to check that all logic branches are covered, and
that complex areas of code are covered.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://trishagee.github.io/static/images/code-review/CodeReviewLogicCoverage.png&#34; alt=&#34;Code coverage for logic&#34; title=&#34;Code coverage for logic&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;can-i-understand-the-tests:e49bb25edf62b34017ea72c340f0c27c&#34;&gt;Can I understand the tests?&lt;/h3&gt;

&lt;p&gt;Having tests that provide adequate coverage is one thing, but if I, as a human, can&amp;rsquo;t understand the tests, they have
limited use - what happens when they break? It&amp;rsquo;ll be hard to know how to fix them.&lt;/p&gt;

&lt;p&gt;Consider the following:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://trishagee.github.io/static/images/code-review/HardToReadTest.png&#34; alt=&#34;Hard to read test&#34; title=&#34;Hard to read test&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s a fairly simple test, but I&amp;rsquo;m not entirely sure what it&amp;rsquo;s testing. Is it
testing the &lt;code&gt;save&lt;/code&gt; method? Or &lt;code&gt;getMyLongId&lt;/code&gt;? And why does it need to do the
same thing twice?&lt;/p&gt;

&lt;p&gt;The intent behind the test might be clearer as:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://trishagee.github.io/static/images/code-review/ClearerTest.png&#34; alt=&#34;More descriptive test&#34; title=&#34;More descriptive test&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;The specific steps you take in order to clarify a test&amp;rsquo;s purpose
will depend upon your language, libraries, team and personal preferences.
This example demonstrates that by choosing clearer names, inlining constants and even adding
comments, an author can make a test more readable by developers other than
him- or herself.&lt;/p&gt;

&lt;h3 id=&#34;do-the-tests-match-the-requirements:e49bb25edf62b34017ea72c340f0c27c&#34;&gt;Do the tests match the requirements?&lt;/h3&gt;

&lt;p&gt;Here&amp;rsquo;s an area that really requires human expertise. Whether the requirements
being met by the code under review are encoded in some formal document,
on a piece of card in a user story, or contained in a bug raised by a user,
the code being reviewed should relate to some initial requirement.&lt;/p&gt;

&lt;p&gt;The reviewer should locate the original requirements and see if:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The tests, whether they&amp;rsquo;re unit, end-to-end, or something else, match the
requirements. For example, if the requirements are &amp;ldquo;should allow the special
characters &amp;lsquo;#&amp;rsquo;, &amp;lsquo;!&amp;rsquo; and &amp;lsquo;&amp;amp;&amp;rsquo; in the password field&amp;rdquo;, there should be a test
using these values in the password field. If the test uses different special characters,
then it&amp;rsquo;s not proving the code meets the criteria.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The tests cover all the criteria mentioned. In our example of
special characters, the requirements might go on to say &amp;ldquo;&amp;hellip;and give the
user an error message if other special characters are used&amp;rdquo;. Here, the
reviewer should be checking there&amp;rsquo;s a test for what happens when an invalid
character is used.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;can-you-the-reviewer-think-of-cases-that-are-not-covered-by-the-existing-tests:e49bb25edf62b34017ea72c340f0c27c&#34;&gt;Can you, the reviewer, think of cases that are not covered by the existing tests?&lt;/h3&gt;

&lt;p&gt;Often our requirements aren&amp;rsquo;t clearly specified. Under these circumstances, the reviewer should think of edge
cases that weren&amp;rsquo;t covered in the original bug/issue/story.&lt;/p&gt;

&lt;p&gt;If our new features is, for example, &amp;ldquo;Give the user the ability to log on to the system&amp;rdquo;, the reviewer could
be thinking &amp;ldquo;What happens if the user enters null for the username?&amp;rdquo;,
or &amp;ldquo;What sort of error occurs if the user doesn&amp;rsquo;t exist in the system?&amp;rdquo;. If
these tests exist in the code being reviewed, then the reviewer has
increased confidence that the code itself handles these circumstances. If the
tests for these exceptional cases don&amp;rsquo;t exist, then the reviewer has to go
through the code to see if they have been handled.&lt;/p&gt;

&lt;p&gt;If the code exists but the tests don&amp;rsquo;t, it&amp;rsquo;s up to your team to decide what
your policies are - do you make the author add those tests? Or are you satisfied that the code review proved the
edge cases were covered?&lt;/p&gt;

&lt;h3 id=&#34;are-there-tests-to-document-the-limitations-of-the-code:e49bb25edf62b34017ea72c340f0c27c&#34;&gt;Are there tests to document the limitations of the code?&lt;/h3&gt;

&lt;p&gt;As a reviewer, it&amp;rsquo;s often possible to see limitations in the code being
reviewed.  These limitations are sometimes intentional - for example, a batch
process that can only handle a maximum of 1000 items per batch.&lt;/p&gt;

&lt;p&gt;One approach to documenting these intentional limitations would be to
explicitly test them.  In our example above, we might have a test that
proves that some sort of exception is thrown if your batch size is bigger
than 1000.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s not mandatory to express these limitations in an automated test, but if
an author has written a test that shows the limits of what they&amp;rsquo;ve
implemented, having a test implies these limits are intentional (and documented)
and not merely an oversight.&lt;/p&gt;

&lt;h3 id=&#34;are-the-tests-in-the-code-review-the-right-type-level:e49bb25edf62b34017ea72c340f0c27c&#34;&gt;Are the tests in the code review the right type/level?&lt;/h3&gt;

&lt;p&gt;For example, is the author doing expensive integration tests where a unit
test might suffice? Have they written performance micro-benchmarks that will
not run effectively or in a consistent fashion in the CI environment?&lt;/p&gt;

&lt;p&gt;Ideally your automated tests will run as quickly as possible, which means
that expensive end-to-end tests may not be required to check all types of
features.  A method that performs some mathematical function, or boolean
logic check, seems like a good candidate for a method-level unit test.&lt;/p&gt;

&lt;h3 id=&#34;are-there-security-tests-that-need-to-be-written:e49bb25edf62b34017ea72c340f0c27c&#34;&gt;Are there security tests that need to be written?&lt;/h3&gt;

&lt;p&gt;Security is one area that code reviews can really benefit. We&amp;rsquo;ll do a whole
post on security later, but on the testing topic, we can write tests for
a number of common problems.  For example, if we were writing the log-in code
above, we might want to also write a test that shows that we cannot enter
the protected area of the site (or call protected API methods) without first
authenticating.&lt;/p&gt;

&lt;h3 id=&#34;performance-tests:e49bb25edf62b34017ea72c340f0c27c&#34;&gt;Performance Tests&lt;/h3&gt;

&lt;p&gt;In the previous post I talked about performance as being an area a reviewer
might be examining. Automated performance tests are obviously another type of
test that I could have explored in this article, but I will leave discussion
of these types of tests for a later article about looking specifically at performance
aspects in a code review.&lt;/p&gt;

&lt;h3 id=&#34;reviewers-can-write-tests-too:e49bb25edf62b34017ea72c340f0c27c&#34;&gt;Reviewers can write tests too.&lt;/h3&gt;

&lt;p&gt;Different organisations have different approaches to code reviews - sometimes
it&amp;rsquo;s very clear that the author is responsible for making all the code
changes required, sometimes it&amp;rsquo;s more collaborative with the reviewer
committing suggestions to the code themselves.&lt;/p&gt;

&lt;p&gt;Whichever approach you take, as a reviewer you may find that writing some
additional tests to poke at the code in the review can be very valuable for
understanding that code, in the same way that firing up the UI and playing
with a new feature is valuable. Some methods and code review tools make it easier to experiment with the code than
others. It&amp;rsquo;s in the team&amp;rsquo;s interest to make it as easy as possible to view and play with the code
in a code review.&lt;/p&gt;

&lt;p&gt;It may be valuable to submit the additional tests as part of the review, but
equally it may not be necessary, for example if experimentation has given me,
the reviewer, satisfactory answers to my questions.&lt;/p&gt;

&lt;h3 id=&#34;in-summary:e49bb25edf62b34017ea72c340f0c27c&#34;&gt;In Summary&lt;/h3&gt;

&lt;p&gt;There are many advantages to performing a code review, no matter how you approach the process in your organisation.
It&amp;rsquo;s possible to use code reviews to find potential problems with the code &lt;em&gt;before&lt;/em&gt; it is integrated into the main
code base, while it&amp;rsquo;s still inexpensive to fix and the context is still in the developer&amp;rsquo;s head.&lt;/p&gt;

&lt;p&gt;As a code reviewer, you should be checking
that the original developer has put some thought into the ways his or her
code could be used, under which conditions it might break, and dealt with
edge cases, preferably &amp;ldquo;documenting&amp;rdquo; the expected behaviour (both under
normal use and exceptional circumstances) with automated tests. The tests can give you an idea
of what the code is supposed to do, and, if they pass, prove that it does
just that.&lt;/p&gt;

&lt;p&gt;If the reviewer checks for the existence of tests and checks the correctness of
the tests, as a team you can have pretty high confidence that the code works.
Moreover, if these tests are run regularly in a CI environment, you can see
that the code &lt;em&gt;continues&lt;/em&gt; to work - they provide automated regression
checking. If code reviewers place a high value on having good quality
tests for the code they are reviewing, the value of this code review
continues long after the reviewer presses the &amp;ldquo;Accept&amp;rdquo; button.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://trishagee.github.io/static/images/code-review/Approve.png&#34; alt=&#34;Accept&#34; title=&#34;Accept&#34; /&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java 8</title>
      <link>http://trishagee.github.io/drafts/java_8/</link>
      <pubDate>Thu, 23 Jul 2015 00:00:00 UTC</pubDate>
      <author>Trisha Gee</author>
      <guid>http://trishagee.github.io/drafts/java_8/</guid>
      <description>

&lt;p&gt;I&amp;rsquo;ve been giving a presentation showing &amp;ldquo;Java 8 in Anger&amp;rdquo; - no, it&amp;rsquo;s not that the most recent release of Java has me
particularly enraged, &amp;ldquo;in anger&amp;rdquo; is (apparently) a British phrase meaning &amp;ldquo;in practice&amp;rdquo; or &amp;ldquo;in the real world&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;The aim of this talk is to demo, with live code, how to use some of the Java 8 features like Lambda Expressions and
the Streams API to solve some of the coding problems you might come across in your day job as a developer.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m not going to transcribe the whole talk for this article, it probably works best (if you&amp;rsquo;re interested) to
watch the video instead. What I do want to do is to use the application from the presentation to explore some
specific Java 8 features in more detail. If you&amp;rsquo;re interested in the wider context, I&amp;rsquo;ve got
&lt;a href=&#34;http://trishagee.github.io/presentation/java8_in_anger/&#34;&gt;links to the videos and source code&lt;/a&gt; on my blog.&lt;/p&gt;

&lt;h3 id=&#34;method-references-and-new-methods-in-java-8:d169180f3a40e9c29149c257bc7fd971&#34;&gt;Method References and New Methods in Java 8&lt;/h3&gt;

&lt;p&gt;The first section where we start using some of the new methods available in Java 8 is when we&amp;rsquo;re building up a
leaderboard of top tweeters. This leaderboard will be a table of the Twitter users who have tweeted the most, in
descending order.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://trishagee.github.io/static/images/java8/leaderboard.png&#34; alt=&#34;Twitter Leaderboard&#34; title=&#34;Twitter Leaderboard&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;We store every Twitter handle we see in as a key in a &lt;code&gt;Map&lt;/code&gt;, and for
the value we have a &lt;code&gt;TwitterUser&lt;/code&gt; (an object to represent this particular user). When we
see a new Twitter handle, we want to create a &lt;code&gt;TwitterUser&lt;/code&gt; for this person and store it in the map, keyed against
this Twitter handle.&lt;/p&gt;

&lt;p&gt;Pre-Java-8, we&amp;rsquo;d write something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private final Map&amp;lt;String, TwitterUser&amp;gt; allTwitterUsers = new HashMap&amp;lt;&amp;gt;();

public void onMessage(String twitterHandle) {
    TwitterUser twitterUser = allTwitterUsers.get(twitterHandle);
    if (twitterUser == null) {
        twitterUser = new TwitterUser(twitterHandle);
        allTwitterUsers.put(twitterHandle, twitterUser);
    }
    // then do stuff...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But Java 8 has not only given us lambdas and streams, it&amp;rsquo;s added new methods to some of our favourite classes.  &lt;code&gt;Map&lt;/code&gt;
now has a &lt;code&gt;computeIfAbsent()&lt;/code&gt; method which allows you to define what to do if an item doesn&amp;rsquo;t exist in the map.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private final Map&amp;lt;String, TwitterUser&amp;gt; allTwitterUsers = new HashMap&amp;lt;&amp;gt;();

public void onMessage(String twitterHandle) {
    TwitterUser twitterUser = allTwitterUsers.computeIfAbsent(twitterHandle, 
                                                              TwitterUser::new);
    // then do stuff...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This does the same thing as the first example and is clearly far fewer lines of code, especially as it also makes use
of &lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html&#34;&gt;Method References&lt;/a&gt;, which usually work
out to be even shorter than lambda expressions. As a long-term Java programmer with limited exposure to other
languages, although this may be shorter, learning to write code this way is going to take me a while to get used to.&lt;/p&gt;

&lt;p&gt;Fortunately for me and my old-school Java approach, &lt;a href=&#34;www.jetbrains.com/idea/&#34;&gt;IntelliJ IDEA&lt;/a&gt; can help me get to
grips with the new syntax. When I first came to Java 8, I found it more understandable (although &lt;em&gt;much&lt;/em&gt; more code)
to call these sorts of methods using an anonymous inner class rather than a lambda expression or a method reference.
IntelliJ IDEA can help create this anonymous inner class and convert it into something more Java 8-ish:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://trishagee.github.io/static/images/java8/ReplaceWithMethodReference.gif&#34; alt=&#34;Convert to method reference&#34; title=&#34;Convert to method reference&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Method references are going to take me a while to grasp instinctively, but I am starting to see how the succinct
syntax could be more expressive, once I get used to it - &lt;code&gt;computeifAbsent()&lt;/code&gt; is going to call a constructor on
&lt;code&gt;TwitterUser&lt;/code&gt; to create a new user if one doesn&amp;rsquo;t already exist in the map.&lt;/p&gt;

&lt;h3 id=&#34;streams:d169180f3a40e9c29149c257bc7fd971&#34;&gt;Streams&lt;/h3&gt;

&lt;p&gt;Next we need to increment the number of times we&amp;rsquo;ve seen
this &lt;code&gt;TwitterUser&lt;/code&gt;, and then figure out how this impacts our leaderboard of tweeters. We can use the
&lt;a href=&#34;http://www.oracle.com/technetwork/articles/java/ma14-java-se-8-streams-2177646.html&#34;&gt;Streams API&lt;/a&gt; to
turn our map of all Twitter users into a list of the top ten Tweeters.&lt;/p&gt;

&lt;p&gt;First we need to sort our &lt;code&gt;TwitterUsers&lt;/code&gt; according to the number of times they&amp;rsquo;ve tweeted.
There&amp;rsquo;s a &lt;code&gt;sorted()&lt;/code&gt; method on &lt;code&gt;Stream&lt;/code&gt; which takes a &lt;code&gt;Comparator&lt;/code&gt;, so it seems logical to use this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void onMessage(String twitterHandle) {
    TwitterUser twitterUser = allTwitterUsers.computeIfAbsent(twitterHandle, TwitterUser::new);
    twitterUser.incrementCount();

    allTwitterUsers.values().stream()
                   .sorted(new Comparator&amp;lt;TwitterUser&amp;gt;() {
                       @Override
                       public int compare(TwitterUser o1, TwitterUser o2) {
                           return o2.getNumberOfTweets() - o1.getNumberOfTweets();
                       }
                   });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the past, I&amp;rsquo;ve always found comparators a little hard to work with - I&amp;rsquo;m never quite sure if I&amp;rsquo;m supposed to be
subtracting the first object from the second, or vice versa.  Fortunately, once again Java 8 makes things a little
easier. You can use the new &lt;code&gt;Comparator.comparing()&lt;/code&gt; method, which you can combine with a method reference to state
which method on &lt;code&gt;TwitterUser&lt;/code&gt; you want to sort by&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;allTwitterUsers.values().stream()
               .sorted(comparingInt(TwitterUser::getNumberOfTweets))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For a leaderboard which shows the most active tweeters at the top, we need to sort in descending order, which is also
simple and descriptive using this method&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;allTwitterUsers.values().stream()
               .sorted(comparingInt(TwitterUser::getNumberOfTweets).reversed())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that I&amp;rsquo;ve added a static import for &lt;code&gt;comparingInt&lt;/code&gt; to make the code a bit shorter.&lt;/p&gt;

&lt;p&gt;So we&amp;rsquo;ve sorted all the values in the map, now we need to just get the top ten. Since we&amp;rsquo;re using Streams, it&amp;rsquo;s easy
to chain together all the operations we want to perform on our collection, so we add a call to &lt;code&gt;limit&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;allTwitterUsers.values().stream()
               .sorted(comparingInt(TwitterUser::getNumberOfTweets).reversed())
               .limit(10);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far all we&amp;rsquo;ve done is build up a recipe for the operations we want to perform, we need to somehow execute all of
these. Streams have intermediate operations which return a &lt;code&gt;Stream&lt;/code&gt; so that we can perform further operations (for
example, both &lt;code&gt;sorted()&lt;/code&gt; and &lt;code&gt;limit()&lt;/code&gt; above), and terminal operations which will return some concrete value. In this
case, what we want is a new list with these top ten tweeters. Telling the &lt;code&gt;collect&lt;/code&gt; method to put the results
into a &lt;code&gt;List&lt;/code&gt; will do just this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List&amp;lt;TwitterUser&amp;gt; topTen = allTwitterUsers.values().stream()
                                          .sorted(comparingInt(TwitterUser::getNumberOfTweets).reversed())
                                          .limit(10)
                                          .collect(Collectors.toList());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this set of stream operations, we&amp;rsquo;re effectively querying our map of all users. If we were querying a
database instead of a map, we might have written something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT * from TwitterUsers
ORDER BY numberOfTweets DESC
LIMIT 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is how we built the whole operation:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://trishagee.github.io/static/images/java8/Streams.gif&#34; alt=&#34;Using Streams&#34; title=&#34;Using Streams&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;creating-our-own-streams:d169180f3a40e9c29149c257bc7fd971&#34;&gt;Creating our own Streams&lt;/h3&gt;

&lt;p&gt;Another part of this application requires a bar chart, where each bar corresponds to a minute in time over a period
of ten minutes.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://trishagee.github.io/static/images/java8/bar-chart.png&#34; alt=&#34;Bar Chart Widget&#34; title=&#34;Bar Chart Widget&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;When the application starts for the first time, each of these bars needs to be set to an initial value of zero.&lt;/p&gt;

&lt;p&gt;This is not an unusual situation - we&amp;rsquo;ve probably all written code that has to loop for some number of iterations and
initialise some value.  We would probably usually do it using something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public HappinessChartData() {
    int nowMinute = LocalDateTime.now().getMinute();

    for (int i = nowMinute; i &amp;lt; nowMinute + 10; i++) {
        initialiseBarToZero(i);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we also use a very small part of the new
&lt;a href=&#34;http://www.oracle.com/technetwork/articles/java/jf14-date-time-2125367.html&#34;&gt;Date &amp;amp; Time API&lt;/a&gt;.  In the Java 8 world, we
have more options for iterating over values.  In this case, we can create our own &lt;code&gt;IntStream&lt;/code&gt; from a range of
values and perform some operation for each of these values.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public HappinessChartData() {
    int nowMinute = LocalDateTime.now().getMinute();

    IntStream.range(nowMinute, nowMinute + 10)
             .forEach(value -&amp;gt; initialiseBarToZero(value));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can use a lambda expression to specify what to do with each of the values.  As before, we can also
simplify this lambda expression to a method reference.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    IntStream.range(nowMinute, nowMinute + 10)
             .forEach(this::initialiseBarToZero);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This method of iterating is marginally less code, and, once we get used to the new syntax, arguably more readable.
The performance of the two methods is not the same, however, so you&amp;rsquo;ll have to decide which method to use based on
your team&amp;rsquo;s preferences for syntax and the performance requirements of your application.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://trishagee.github.io/static/images/java8/CreateStream.gif&#34; alt=&#34;Create a Stream&#34; title=&#34;Create a Stream&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;file-handling-in-java-8:d169180f3a40e9c29149c257bc7fd971&#34;&gt;File Handling in Java 8&lt;/h3&gt;

&lt;p&gt;Java 7 introduced some really nice features for file handling. Working with files has become even
more intuitive when you combine these Java 7 features with streams.&lt;/p&gt;

&lt;p&gt;In this example, we&amp;rsquo;re parsing a file which contains Tweets recorded from the Twitter firehose.  Each line contains a
different tweet, and what we want to do is filter out the noise (there are lines that contain only the single String
&amp;ldquo;OK&amp;rdquo; as a response from Twitter) and then publish the remaining tweets via websockets.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try (Stream&amp;lt;String&amp;gt; lines = Files.lines(filePath)) {
        lines.filter(s -&amp;gt; !s.equals(&amp;quot;OK&amp;quot;))
             .forEach(tweetsEndpoint::onMessage);
    } catch (IOException e) {
        //error handling here
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, I&amp;rsquo;m not tempted to show the Java 6 version of the code, as the Java 8 version is much simpler.  The first line
uses &lt;a href=&#34;https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html&#34;&gt;try-with-resources&lt;/a&gt;
to obtain a strea, of &lt;code&gt;Strings&lt;/code&gt;, one string per line in our file.  Then we use the &lt;code&gt;filter()&lt;/code&gt;
method to exclude the lines that aren&amp;rsquo;t tweets, and finally publish all the remaining tweets via our websocket
server endpoint.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://trishagee.github.io/static/images/java8/Java7And8.gif&#34; alt=&#34;File handling with Java 8&#34; title=&#34;File handling with Java 8&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;advanced-streams-and-more-collectors:d169180f3a40e9c29149c257bc7fd971&#34;&gt;Advanced Streams and More Collectors&lt;/h3&gt;

&lt;p&gt;The last part of the application that I&amp;rsquo;d like to show you in more depth, is the mood analyser.  The aim of
this small service is to take a single Tweet and figure out the mood of that Tweet in a very rough fashion.  It will
generally decide if a single Tweet is &amp;ldquo;happy&amp;rdquo;, &amp;ldquo;sad&amp;rdquo;, or &amp;ldquo;happy &lt;em&gt;and&lt;/em&gt; sad&amp;rdquo;, and return a comma separated String of
the mood in upper case. So for example:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Today was a great day!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;would be classified as &amp;ldquo;HAPPY&amp;rdquo;,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I&amp;rsquo;m irritated I have to work tomorrow&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;would be &amp;ldquo;SAD&amp;rdquo;, and&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The start of this week was fantastic, but today sucks&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;contains both good and bad news, so would be &amp;ldquo;HAPPY,SAD&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;If I had an automated system for applying moods to Twitter messages, I&amp;rsquo;d be retired on a beach
somewhere, this kind of analysis is very much in demand.  In my application, I settle instead for a very crude method
of classifying the messages - we&amp;rsquo;re going to parse the message and look for words that might imply &amp;ldquo;happy&amp;rdquo; or &amp;ldquo;sad&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;We start with a &lt;code&gt;Map&lt;/code&gt;, which maps words to their associated mood (represented as an enum).  Something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;quot;happy&amp;quot;: HAPPY,
 &amp;quot;fantastic&amp;quot;: HAPPY,
 &amp;quot;awesome&amp;quot;: HAPPY,
 ...
 &amp;quot;sad&amp;quot;: SAD,
 &amp;quot;terrible&amp;quot;: SAD,
 &amp;quot;sucks&amp;quot;: SAD]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are a number of approaches to this problem, this is not a definitive answer. I will demonstrate
with my selected method how you can chain together stream operations to get the output that you need.&lt;/p&gt;

&lt;p&gt;Firstly, we create a stream where each item is a word in the original Twitter message.  We use &lt;code&gt;String&lt;/code&gt;&amp;rsquo;s &lt;code&gt;split()&lt;/code&gt;
method to create an array of words, and use &lt;code&gt;Stream.of()&lt;/code&gt; to turn this into a &lt;code&gt;Stream&lt;/code&gt; of &lt;code&gt;Strings&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Stream.of(twitterMessage.split(&amp;quot;\\s+&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we&amp;rsquo;re going to convert all these words to lowercase, as our map of words to moods only has lowercase keys.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Stream.of(twitterMessage.split(&amp;quot;\\s+&amp;quot;))
      .map(String::toLowerCase)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;map()&lt;/code&gt; method takes one value and turns it into another.  In this case, we want to turn a &lt;code&gt;String&lt;/code&gt; value like
&amp;ldquo;Awesome&amp;rdquo; into its lowercase version, &amp;ldquo;awesome&amp;rdquo;.  It&amp;rsquo;s easy pass in String&amp;rsquo;s &lt;code&gt;toLowerCase()&lt;/code&gt; method as a method
reference to do the conversion.&lt;/p&gt;

&lt;p&gt;Now we have a string in the correct case, we can search our map of words-to-moods for the mood that corresponds to
this word.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Stream.of(twitterMessage.split(&amp;quot;\\s+&amp;quot;))
      .map(String::toLowerCase)
      .map((lowerCaseWord) -&amp;gt; WORD_TO_MOOD.get(lowerCaseWord))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not every word is going to have a corresponding mood in the map, so we&amp;rsquo;re only going to pass non-null moods to the
next step of the pipeline&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Stream.of(twitterMessage.split(&amp;quot;\\s+&amp;quot;))
      .map(String::toLowerCase)
      .map((lowerCaseWord) -&amp;gt; WORD_TO_MOOD.get(lowerCaseWord))
      .filter(mood -&amp;gt; mood != null)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now what I have is a &lt;code&gt;Mood&lt;/code&gt;, an enum value of either &lt;code&gt;HAPPY&lt;/code&gt; or &lt;code&gt;SAD&lt;/code&gt;. Our requirements state that for each tweet, we
need to return one of &amp;ldquo;HAPPY&amp;rdquo;, &amp;ldquo;SAD&amp;rdquo;, or &amp;ldquo;HAPPY,SAD&amp;rdquo;. We don&amp;rsquo;t need an indication of whether there are multiple happy
words or sad words in the same tweet, so we only need one instance of each mood. This is easily done by requiring the
stream to contain only distinct values.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Stream.of(twitterMessage.split(&amp;quot;\\s+&amp;quot;))
      .map(String::toLowerCase)
      .map((lowerCaseWord) -&amp;gt; WORD_TO_MOOD.get(lowerCaseWord))
      .filter(mood -&amp;gt; mood != null)
      .distinct()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;According to our requirements, we need to convert our enum value to a String&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Stream.of(twitterMessage.split(&amp;quot;\\s+&amp;quot;))
      .map(String::toLowerCase)
      .map((lowerCaseWord) -&amp;gt; WORD_TO_MOOD.get(lowerCaseWord))
      .filter(mood -&amp;gt; mood != null)
      .distinct()
      .map((mood) -&amp;gt; mood.name())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally, we want to merge together all the moods found for this message into a comma separated string of moods.
In our previous Stream example, we used &lt;code&gt;Collectors.toList()&lt;/code&gt; to return a &lt;code&gt;List&lt;/code&gt;
of &lt;code&gt;TwitterUsers&lt;/code&gt;. This time, we&amp;rsquo;re going to use another built in collector, &lt;code&gt;Collectors.joining()&lt;/code&gt; and give it the
characters we want to use to separate our results. &lt;code&gt;joining()&lt;/code&gt; will return a &lt;code&gt;String&lt;/code&gt; of your results, separated by
your chosen delimiter. Which means that now in Java 8 we can easily create comma separated strings without having to
iterate over a list and figure out if we&amp;rsquo;re supposed to be putting a comma after this item or not.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Stream.of(twitterMessage.split(&amp;quot;\\s+&amp;quot;))
      .map(String::toLowerCase)
      .map((lowerCaseWord) -&amp;gt; WORD_TO_MOOD.get(lowerCaseWord))
      .filter(mood -&amp;gt; mood != null)
      .distinct()
      .map((mood) -&amp;gt; mood.name())
      .collect(Collectors.joining(&amp;quot;,&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, let&amp;rsquo;s simplify the lambdas to method references where possible, and turn this into a method we can use&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static String identifyMood(String twitterMessage) {
    return Stream.of(twitterMessage.split(&amp;quot;\\s+&amp;quot;))
                 .map(String::toLowerCase)
                 .map(WORD_TO_MOOD::get)
                 .filter(mood -&amp;gt; mood != null)
                 .distinct()
                 .map(Enum::name)
                 .collect(joining(&amp;quot;,&amp;quot;));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we called &lt;code&gt;identifyMood&lt;/code&gt; with the message &amp;ldquo;Yesterday I was sad sad sad, but today is awesome&amp;rdquo;, we&amp;rsquo;ll get the
String &amp;ldquo;SAD,HAPPY&amp;rdquo; in return.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://trishagee.github.io/static/images/java8/AdvancedStreams.gif&#34; alt=&#34;Advanced Streams&#34; title=&#34;Advanced Streams&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;With this example we have seen how you can chain multiple operations to perform fairly complex processing, with limited
lines of code.&lt;/p&gt;

&lt;h3 id=&#34;summary:d169180f3a40e9c29149c257bc7fd971&#34;&gt;Summary&lt;/h3&gt;

&lt;p&gt;Java 8 is more than just a bit of extra syntax to learn, or a couple of new methods that might be useful.
It can change the way we approach solving common problems. With lambda expressions, streams and some of the other
new methods in Java 8, you can use easily perform common operations (for example, &lt;code&gt;computeIfAbsent()&lt;/code&gt; and &lt;code&gt;joining()&lt;/code&gt;),
and you gain a new set of tools, particularly in manipulating data sets.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://trishagee.github.io/drafts/code_review_design/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 UTC</pubDate>
      <author>Trisha Gee</author>
      <guid>http://trishagee.github.io/drafts/code_review_design/</guid>
      <description>&lt;p&gt;While it&amp;rsquo;s great to know that the code does what it is supposed to do, this
focus on tests does not necessarily address the design or architecture of
that code. This will be addressed in this post&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://trishagee.github.io/drafts/how_to_write_a_cfp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 UTC</pubDate>
      <author>Trisha Gee</author>
      <guid>http://trishagee.github.io/drafts/how_to_write_a_cfp/</guid>
      <description>&lt;p&gt;Title
It needs a compelling (and ideally, short) title. Conference attendees will likely glance at the timetable and not necessarily read all
the abstracts - have keywords in the title that will grab the attention. Maybe indicate the level required.  Good examples are things like:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Scala for Java Developers&lt;/li&gt;
&lt;li&gt;Intro to [Technology X]&lt;/li&gt;
&lt;li&gt;[Technology X]: Beyond the Basics&lt;/li&gt;
&lt;li&gt;How [Company Y] scaled to [some insane metric]&lt;/li&gt;
&lt;li&gt;(Martijn&amp;rsquo;s current talk)&lt;/li&gt;
&lt;li&gt;6 million transactions a second&lt;/li&gt;
&lt;li&gt;AngularJS, Java, Groovy, MongoDB working together&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Abstract
Needs to explain:
 - Who the talk is aimed at
 - Vaguely what it&amp;rsquo;s going to cover&lt;/p&gt;

&lt;p&gt;Each conference has a different set of fields to fill in for the talk submissions.  For some, it all has to be in the abstract,
for others, they&amp;rsquo;ll ask for a behind-the-scenes look at the talk, or a structure of how you&amp;rsquo;re going to present it.  For your talk,
whether you&amp;rsquo;ve written it yet or not, you&amp;rsquo;ll need to know:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Who is it aimed at?&lt;/li&gt;
&lt;li&gt;What will they learn?&lt;/li&gt;
&lt;li&gt;Which buzz words will grab attention?&lt;/li&gt;
&lt;li&gt;What story will you tell?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Past performance
 - Get videoed. Even if you&amp;rsquo;re not fantastic, you&amp;rsquo;re miles ahead of an unknown already
 - Get a named event on your CV. Pair if necessary.
 - have a blog if you don&amp;rsquo;t have videos
 - LinkedIn
 - Twitter
 - Be linked to A Name: a company, a person, a conference, a user group.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
